<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta name="generator" content="Doxygen 1.8.17"/>
    <!--    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>-->
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea" style="width: 100%">
        <table cellspacing="0" cellpadding="0" style="margin-bottom: 1em; width: 100%">
            <tbody>
            <tr>
                <td id="projectlogo"><img alt="Logo" src="wrench-logo.png"/></td>
                <td id="projectalign" style="padding-left: 0.5em; margin-bottom: 1em; min-width: 270px">
                    <div id="projectname">WRENCH
                        &#160;<span id="projectnumber">1.11</span>
                    </div>
                    <div id="projectbrief">Cyberinfrastructure Simulation Workbench</div>
                </td>
                <td style="vertical-align: bottom">
                    <a class="link" href="/wrench/1.11/index.html">Overview</a>
                </td>
                <td style="vertical-align: bottom">
                    <a class="link" href="/wrench/1.11/install.html">Installation</a>
                </td>
                <td style="vertical-align: bottom">
                    <a class="link" href="/wrench/1.11/getting-started.html">Getting Started</a>
                </td>
                <td style="vertical-align: bottom">
                    <a class="link" href="/wrench/1.11/wrench-101.html">WRENCH 101</a>
                </td>
                <td style="vertical-align: bottom">
                    <a class="link" href="/wrench/1.11/wrench-102.html">WRENCH 102</a>
                </td>
                <td style="vertical-align: bottom">
                    <div class="dropdown">
                        <button class="dropbtn link">APIs Reference</button>
                        <div class="dropdown-content">
                            <a class="small dropdown-item link"
                               href="/wrench/1.11/user/annotated.html">User</a>
                            <a class="small dropdown-item link"
                               href="/wrench/1.11/developer/annotated.html">Developer</a>
                            <a class="small dropdown-item link"
                               href="/wrench/1.11/internal/annotated.html">Internal</a>
                        </div>
                    </div>
                </td>
                <td style="float: right; min-width: 230px; padding-top: 1em">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
            </tr>
            </tbody>
        </table>
    </div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">WRENCH 102 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#wrench-102-WMS-10000ft">Basic blueprint for a WMS implementation</a></li>
<li class="level1"><a href="#wrench-102-obtain-information">A) Obtaining information about services</a></li>
<li class="level1"><a href="#wrench-102-WMS-services">B)  Interacting with services</a></li>
<li class="level1"><a href="#wrench-102-WMS-events">C) Workflow execution events</a></li>
<li class="level1"><a href="#wrench-102-WMS-exceptions">Exceptions</a></li>
<li class="level1"><a href="#wrench-102-WMS-hardware">Finding information and interacting with hardware resources</a></li>
<li class="level1"><a href="#wrench-102-WMS-schedulers">Schedulers for decision-making</a></li>
<li class="level1"><a href="#wrench-102-WMS-logging">Logging</a></li>
</ul>
</div>
<div class="textblock"><p>A Workflow Management System (WMS) is software that makes all decisions and takes all actions for executing a workflow using cyberinfrastructure services. It is thus a crucial component in every WRENCH simulator. WRENCH does not provide any WMS implementation, but provides the means for developing custom WMSs. This page is meant to provide high-level and detailed information about implementing a WMS in WRENCH. Full API details are provided in the <a href="./developer/annotated.html">Developer API Reference</a>.</p>
<h1><a class="anchor" id="wrench-102-WMS-10000ft"></a>
Basic blueprint for a WMS implementation</h1>
<p>A WMS implementation needs to use many WRENCH classes, which are accessed by including a single header file:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;wrench-dev.h&gt;</span></div>
</div><!-- fragment --><p>A WMS implementation must derive the <code><a class="el" href="classwrench_1_1_w_m_s.html" title="A workflow management system (WMS)">wrench::WMS</a></code> class, which means that it can override several virtual member functions, but also that a WMS is a service. As such, it has a <code>main()</code> function that goes through a simple loop as follows:</p>
<div class="fragment"><div class="line">// A) obtain information about running services</div>
<div class="line">while (workflow execution is not completed/failed) {</div>
<div class="line">  // B) interact with services </div>
<div class="line">  // C) wait for an event and react to it</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the next three sections, we give details on how to implement A, B, and C in the code above. To provide context, we make frequent references to the WMS implementations in the example simulators in the <code>examples/</code> directory. Afterwards are a few sections that highlight features and functionality relevant to WMS development.</p>
<h1><a class="anchor" id="wrench-102-obtain-information"></a>
A) Obtaining information about services</h1>
<h2><a class="anchor" id="wrench-102-obtain-information-discovering"></a>
Discovering running services</h2>
<p>The <code><a class="el" href="classwrench_1_1_w_m_s.html" title="A workflow management system (WMS)">wrench::WMS</a></code> base class implements a set of member functions named <code>wrench::WMS::getAvailableComputeServices()</code>, <code>wrench::WMS::getAvailableStorageServices()</code>, <code>wrench::WMS::getAvailableNetworkProximityServices()</code>, etc. These member functions return sets of services that can be used by the WMS to execute its workflow. Some of these member functions are templated to retrieve only particular kind of services. For instance, the <code>wrench::WMS::getAvailableComputeServices&lt;T&gt;()</code> takes a template argument to retrieve particular kinds of compute services. In the example simulator in <code>examples/basic-examples/bare-metal-chain</code>, the WMS implementation in <code>OneTaskAtATimeWMS.cpp</code> includes the following call:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> compute_service = *(this-&gt;getAvailableComputeServices&lt;BareMetalComputeService&gt;().begin());</div>
</div><!-- fragment --><p>This call stores the first of the bare-metal compute services available to the WMS for executing workflow tasks in the <code>compute_service</code> variable. In this example, the simulator always passes exactly one bare-metal service to the WMS, so this code is valid. However, <code>wrench::WMS::getAvailableComputeServices&lt;T&gt;()</code> can return an empty set.</p>
<p>The above member functions (as well as, for instance, <code><a class="el" href="classwrench_1_1_simulation.html#a7cf70e5793758149a8bf29992d870c91" title="Method to add a service to the simulation.">wrench::Simulation::add()</a></code>) return shared pointers (i.e., <code>std::shared_ptr&lt;&gt;</code>) to the service instances. This is to free the developer from the responsibility of freeing memory.</p>
<h2><a class="anchor" id="wrench-102-obtain-information-finding"></a>
Finding out information about running services</h2>
<p>Most service classes provide member functions to get information about the capabilities and properties of the services. For instance, a <code><a class="el" href="classwrench_1_1_compute_service.html" title="The compute service base class.">wrench::ComputeService</a></code> has a <code>wrench::ComputeService::getNumHosts()</code> member function that returns how many compute hosts the service has access to in total. A <code><a class="el" href="classwrench_1_1_storage_service.html" title="The storage service base class.">wrench::StorageService</a></code> has a <code>wrench::StorageService::getFreeSpace()</code> member function to find out how many bytes of free space are available on it. And so on...</p>
<p>To take a concrete example, consider the WMS implementation in <code>examples/basic-examples/batch-bag-of-tasks/TwoTasksAtATimeBatchWMS.cpp</code>. This WMS finds out the compute speed of the cores of the compute nodes available to a <code><a class="el" href="classwrench_1_1_batch_compute_service.html" title="A batch-scheduled compute service that manages a set of compute hosts and controls access to their re...">wrench::BatchComputeService</a></code> as:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> core_flop_rate = (*(batch_service-&gt;getCoreFlopRate().begin())).second;</div>
</div><!-- fragment --><p>Member function <code>wrench::ComputeService::getCoreFlopRate()</code> returns a map of core compute speeds indexed by hostname (the map thus has one element per compute node available to the service). Since the compute nodes of a batch compute service are homogeneous, the above code simply grabs the core speed value of the first element in the map.</p>
<p>It is important to note that these member functions actually involve communication with the service, and thus incur overhead that is part of the simulation (as if, in the real-world, you would contact a running service with a request for information over the network). This is why the line of code above, in that example WMS, is executed once and the core compute speed is stored in the <code>core_flop_rate</code> variable to be re-used by the WMS repeatedly throughout its execution.</p>
<h1><a class="anchor" id="wrench-102-WMS-services"></a>
B)  Interacting with services</h1>
<p>A WMS can have many and complex interactions with services, especially with compute and storage services. In this section, we describe how WRENCH makes these interactions relatively easy, providing examples for each kind of interaction for each kind of service.</p>
<h2><a class="anchor" id="wrench-102-WMS-services-managers"></a>
Job Manager and Data Movement Manager</h2>
<p>As expected, each service type provides its own API. For instance, a network proximity service provides member functions to query the service's host distance databases. The <a href="./developer/annotated.html">Developer API Reference</a> provides all necessary documentation, which also explains which member functions are synchronous and which are asynchronous (in which case some <a class="el" href="wrench-102.html#wrench-102-WMS-events">event</a> will occur in the future). <b>However, the WRENCH developer will find that many member functions that one would expect are nowhere to be found. For instance, the compute services do not have member functions for submitting workflow tasks for execution!</b></p>
<p>The rationale for the above is that many member functions need to be asynchronous so that the WMS can use services concurrently. For instance, a WMS could submit a compute job to two distinct compute services asynchronously, and then wait for the service which completes its job first and cancel the job on the other service. Exposing this asynchronicity to the WMS would require that the WRENCH developer use data structures to perform the necessary bookkeeping of ongoing service interactions, and process incoming control messages from the services on the (simulated) network or alternately register many callbacks. Instead, WRENCH provides <b>managers</b>. One can think of managers as separate threads that handle all asynchronous interactions with services, and which have been implemented for your convenience to make interacting with services easy.</p>
<p>There are two managers: a <b>job manager</b> (class <code>wrench::JobManager</code>) and a <b>data movement manager</b> (class <code>wrench::DataMovementManager</code>). The base <code><a class="el" href="classwrench_1_1_w_m_s.html" title="A workflow management system (WMS)">wrench::WMS</a></code> class provides two member functions for instantiating and starting these managers: <code>wrench::WMS::createJobManager()</code> and <code>wrench::WMS::createDataMovementManager()</code>.</p>
<p>Creating these managers typically is the first thing a WMS does. For instance, the WMS in <code>examples/basic-examples/bare-metal-data-movement/DataMovementWMS.cpp</code> starts by doing:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> job_manager = this-&gt;createJobManager();</div>
<div class="line"><span class="keyword">auto</span> data_movement_manager = this-&gt;createDataMovementManager();</div>
</div><!-- fragment --><p>Each manager has its own documented API, and is discussed further in sections below.</p>
<h2><a class="anchor" id="wrench-102-WMS-services-storage"></a>
Interacting with storage services</h2>
<p>The possible interactions between a WMS and a storage service include:</p>
<ul>
<li>Synchronously check that a file exists</li>
<li>Synchronously read a file (rarely used by a WMS but included for completeness)</li>
<li>Synchronously write a file (rarely used by a WMS but included for completeness)</li>
<li>Synchronously delete a file</li>
<li>Synchronously copy a file from one storage service to another</li>
<li>Asynchronously copy a file from one storage service to another</li>
</ul>
<p>The first 4 interactions above are done by calling member functions of the <code><a class="el" href="classwrench_1_1_storage_service.html" title="The storage service base class.">wrench::StorageService</a></code> class. The last two are done via a Data Movement Manager, i.e., by calling member functions of the <code>wrench::DataMovementManager</code> class. Some of these member functions take an optional <code><a class="el" href="classwrench_1_1_file_registry_service.html" title="A file registry service (a.k.a. replica catalog) that holds a database of which files are available a...">wrench::FileRegistryService</a></code> argument, in which case they will also update entries in a file registry service (e.g., removing an entry when a file is deleted).</p>
<p>See this page for concrete examples of interactions with a <code><a class="el" href="classwrench_1_1_simple_storage_service.html" title="A storage service that provides direct access to some storage resources (e.g., one or more disks)....">wrench::SimpleStorageService</a></code>.</p>
<h2><a class="anchor" id="wrench-102-WMS-services-compute"></a>
Interacting with compute services</h2>
<h3><a class="anchor" id="wrench-102-WMS-services-compute-job"></a>
The Job abstraction</h3>
<p>The main activity of a WMS is to execute workflow tasks on compute services. Rather than submitting tasks directly to compute services, a WMS must create "jobs", which can comprise multiple tasks and involve data copy/deletion operations. The job abstraction is powerful and greatly simplifies the task of a WMS while affording flexibility.</p>
<p>There are two kinds of jobs in WRENCH: <code>wrench::PilotJob</code> and <code>wrench::StandardJob</code>. A pilot job (sometimes called a "placeholder job" in the literature) is a concept that is mostly relevant for batch scheduling. In a nutshell, it is a job that allows late binding of tasks to resources. It is submitted to a compute service (provided that service supports pilot jobs), and when it starts it just looks to the WMS like a temporary (bare-metal) compute service to which standard jobs can be submitted.</p>
<p>The most common kind of job is the <b>standard job</b>. A standard job is a unit of execution by which a WMS tells a compute service to do a set of operations. More specifically, in its most complete form, a standard job specifies:</p>
<ul>
<li>A set (in fact a vector) of <code><a class="el" href="classwrench_1_1_workflow_task.html" title="A computational task in a Workflow.">wrench::WorkflowTask</a></code> to execute, so that each task without all its predecessors in the set is ready;</li>
<li>A <code>std::map</code> of <code>&lt;<a class="el" href="classwrench_1_1_workflow_file.html" title="A data file used/produced by a WorkflowTask in a Workflow.">wrench::WorkflowFile</a>*, std::shared_ptr&lt;<a class="el" href="classwrench_1_1_storage_service.html" title="The storage service base class.">wrench::StorageService</a>&gt;&gt;</code> pairs that specifies from which storage services particular input files should be read and to which storage services output files should be written;</li>
<li>A set of file copy operations to be performed before executing the tasks;</li>
<li>A set of file copy operations to be performed after executing the tasks; and</li>
<li>A set of file deletion operations to be performed after executing the tasks and file copy operations.</li>
</ul>
<p>Any of the above can actually be empty, and in the extreme a standard job can do nothing.</p>
<p>Standard jobs and pilot jobs are created via the job manager, which provides a <code>wrench::JobManager::createPilotJob()</code> member function and several versions of a <code>wrench::JobManager::createStandardJob()</code> member function. Briefly put, the job manager is a job factory.</p>
<p>In addition to member functions for job creation, the job manager also provides the following:</p>
<ul>
<li><code>wrench::JobManager::submitJob()</code>: asynchronous submission of a job to a compute service.</li>
<li><code>wrench::JobManager::terminateJob()</code>: synchronous termination of a previously submitted job.</li>
<li><code>wrench::JobManager::getPendingPilotJobs()</code>: synchronous retrieval of the list of pending pilot jobs.</li>
<li><code>wrench::JobManager::getRunningPilotJobs()</code>: synchronous retrieval of the list of running pilot jobs.</li>
<li><code>wrench::JobManager::forgetJob()</code>: free memory for a completed/failed job.</li>
</ul>
<p>The next section gives many examples of interactions with each kind of compute service.</p>
<p>Click on the following links to see detailed descriptions and examples of how jobs are submitted to each compute service type:</p>
<ul>
<li>Bare-metal compute service</li>
<li>Batch compute service</li>
<li>Cloud compute service</li>
<li>Virtualized cluster compute service</li>
<li>HTCondor compute service</li>
</ul>
<h2><a class="anchor" id="wrench-102-WMS-services-registry"></a>
Interacting with file registry services</h2>
<p>Interaction with a file registry service is straightforward and done by directly calling member functions of the <code><a class="el" href="classwrench_1_1_file_registry_service.html" title="A file registry service (a.k.a. replica catalog) that holds a database of which files are available a...">wrench::FileRegistryService</a></code> class. Note that often file registry service entries are managed automatically, e.g., via calls to <code>wrench::DataMovementManager</code> and <code><a class="el" href="classwrench_1_1_storage_service.html" title="The storage service base class.">wrench::StorageService</a></code> member functions. So often a WMS does not need to interact with the file registry service.</p>
<p>Adding/removing an entry to a file registry service is done as follows:</p>
<div class="fragment"><div class="line">fr_service = this-&gt;getAvailableFileRegistryService();</div>
<div class="line">wrench::WorkflowFile *some_file  = ...;</div>
<div class="line">std::shared_ptr&lt;wrench::StorageService&gt; some_storage_service = ...;</div>
<div class="line"> </div>
<div class="line">[...]</div>
<div class="line"> </div>
<div class="line">fr_service-&gt;addEntry(some_file, wrench::FileLocation::LOCATION(some_storage_service));</div>
<div class="line">fr_service-&gt;removeEntry(some_file, wrench::FileLocatio::LOCATION(some_storage_service));</div>
</div><!-- fragment --><p>The <code>wrench::FileLocation</code> class is a convenient abstraction for a file copy available at some storage service.</p>
<p>Retrieving all entries for a given file is done as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="classwrench_1_1_workflow_file.html">wrench::WorkflowFile</a> *some_file = ...;</div>
<div class="line"> </div>
<div class="line">[...]</div>
<div class="line"> </div>
<div class="line">std::set&lt;std::shared_ptr&lt;wrench::FileLocation&gt;&gt; entries;</div>
<div class="line">entries = fr_service-&gt;lookupEntry(some_file);</div>
</div><!-- fragment --><p>If a network proximity service is running, it is possible to retrieve entries for a file sorted by non-decreasing proximity from some reference host. Returned entries are stored in a (sorted) <code>std::map</code> where the keys are network distances to the reference host. For instance:</p>
<div class="fragment"><div class="line"><a class="code" href="classwrench_1_1_workflow_file.html">wrench::WorkflowFile</a> *some_file = ...;</div>
<div class="line">std::shared_ptr&lt;wrench::NetworkProximityService&gt; np_service = </div>
<div class="line">  *(this-&gt;getAvailableNetworkProximityServices().begin());</div>
<div class="line"> </div>
<div class="line">[...]</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> entries = fr_service-&gt;lookupEntry(some_file, <span class="stringliteral">&quot;ReferenceHost&quot;</span>, np_service);</div>
</div><!-- fragment --><p>See the documentation of <code><a class="el" href="classwrench_1_1_file_registry_service.html" title="A file registry service (a.k.a. replica catalog) that holds a database of which files are available a...">wrench::FileRegistryService</a></code> for more API member functions.</p>
<h2><a class="anchor" id="wrench-102-WMS-services-network"></a>
Interacting with network proximity services</h2>
<p>Querying a network proximity service is straightforward. For instance, to obtain a measure of the network distance between hosts "Host1" and "Host2", one simply does:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;wrench::NetworkProximityService&gt; np_service = </div>
<div class="line">  *(this-&gt;getAvailableNetworkProximityServices().begin());</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> distance = np_service-&gt;query(std::make_pair(<span class="stringliteral">&quot;Host1&quot;</span>,<span class="stringliteral">&quot;Host2&quot;</span>));</div>
</div><!-- fragment --><p>This distance corresponds to half the round-trip-time, in seconds, between the two hosts. If the service is configured to use the Vivaldi coordinate-based system, as in our example above, this distance is actually derived from network coordinates, as computed by the Vivaldi algorithm. In this case, one can actually ask for these coordinates for any given host:</p>
<div class="fragment"><div class="line">std::pair&lt;double,double&gt; coords = np_service-&gt;getCoordinates(<span class="stringliteral">&quot;Host1&quot;</span>);</div>
</div><!-- fragment --><p>See the documentation of <code><a class="el" href="classwrench_1_1_network_proximity_service.html" title="A network proximity service that continuously estimates inter-host latencies and can be queried for s...">wrench::NetworkProximityService</a></code> for more API member functions.</p>
<h1><a class="anchor" id="wrench-102-WMS-events"></a>
C) Workflow execution events</h1>
<p>Because the WMS performs asynchronous operations, it needs to wait for and re-act to events. This is done by calling the <code>wrench::WMS::waitForAndProcessNextEvent()</code> member function implemented by the base <code><a class="el" href="classwrench_1_1_w_m_s.html" title="A workflow management system (WMS)">wrench::WMS</a></code> class. A call to this member function blocks until some event occurs and then calls a callback member function. The possible event classes all derive from the <code>wrench::WorkflowExecutionEvent</code> class, and a WMS can override the callback member function for each possible event (the default member function does nothing but print some log message). These overridable callback member functions are:</p>
<ul>
<li><code>wrench::WMS::processEventStandardJobCompletion()</code>: react to a standard job completion</li>
<li><code>wrench::WMS::processEventStandardJobFailure()</code>: react to a standard job failure</li>
<li><code>wrench::WMS::processEventPilotJobStart()</code>: react to a pilot job beginning execution</li>
<li><code>wrench::WMS::processEventPilotJobExpiration()</code>: react to a pilot job expiration</li>
<li><code>wrench::WMS::processEventFileCopyCompletion()</code>: react to a file copy completion</li>
<li><code>wrench::WMS::processEventFileCopyFailure()</code>: react to a file copy failure</li>
</ul>
<p>Each member function above takes in an event object as parameter. In the case of failure, the event includes a <code>wrench::FailureCause</code> object, which can be accessed to analyze (or just display) the root cause of the failure.</p>
<p>Consider the WMS in <code>examples/basic-examples/bare-metal-bag-of-tasks/TwoTasksAtATimeWMS.cpp</code>. At each each iteration of its main loop it does:</p>
<div class="fragment"><div class="line"><span class="comment">// Submit some standard job to some compute  service</span></div>
<div class="line">job_manager-&gt;submitJob(...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wait for and process next event</span></div>
<div class="line">this-&gt;waitForAndProcessNextEvent();</div>
</div><!-- fragment --><p>In this simple example, only one of two events could occur at this point: a standard job completion or a standard job failure. As a result, this WMS overrides the two corresponding member functions as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TwoTasksAtATimeWMS::processEventStandardJobCompletion(</div>
<div class="line">               std::shared_ptr&lt;StandardJobCompletedEvent&gt; event) {</div>
<div class="line">  <span class="comment">// Retrieve the job that this event is for </span></div>
<div class="line">  <span class="keyword">auto</span> job = <span class="keyword">event</span>-&gt;standard_job;</div>
<div class="line">  <span class="comment">// Print some message for each task in the job</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp;task : job-&gt;getTasks()) {</div>
<div class="line">    std::cerr  &lt;&lt; <span class="stringliteral">&quot;Notified that a standard job has completed task &quot;</span> &lt;&lt; task-&gt;getID() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> TwoTasksAtATimeWMS::processEventStandardJobFailure(</div>
<div class="line">               std::shared_ptr&lt;StandardJobFailedEvent&gt; event) {</div>
<div class="line">  <span class="comment">// Retrieve the job that this event is for </span></div>
<div class="line">  <span class="keyword">auto</span> job = <span class="keyword">event</span>-&gt;standard_job;</div>
<div class="line">  std::cerr  &lt;&lt; <span class="stringliteral">&quot;Notified that a standard job has failed (failure cause: &quot;</span>;</div>
<div class="line">  std::cerr &lt;&lt; <span class="keyword">event</span>-&gt;failure_cause-&gt;toString() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt;  std::endl;</div>
<div class="line">  <span class="comment">// Print some message for each task in the job if it has failed</span></div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;As a result, the following tasks have failed:&quot;</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp;task : job-&gt;getTasks()) { </div>
<div class="line">    <span class="keywordflow">if</span> (task-&gt;getState != WorkflowTask::COMPLETE) { </div>
<div class="line">      std::cerr  &lt;&lt; <span class="stringliteral">&quot;  - &quot;</span> &lt;&lt; task-&gt;getID() &lt;&lt; std::endl;</div>
<div class="line">    }       </div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>You may note some difference between the above code and that in <code>examples/basic-examples/bare-metal-bag-of-tasks/TwoTasksAtATimeWMS.cpp</code>. This is for clarity purposes, and especially because we have not yet explained how WRENCH does message logging. See <a class="el" href="wrench-102.html#wrench-102-WMS-logging">an upcoming section about logging</a>.</p>
<p>While the above callbacks are convenient, sometimes it is desirable to do things more manually. That is, wait for an event and then process it in the code of the main loop of the WMS rather than in a callback member function. This is done by calling the <code>wrench::waitForNextEvent()</code> member function. For instance, the WMS in <code>examples/basic-examples/bare-metal-data-movement/DataMovementWMS.cpp</code> does it as:</p>
<div class="fragment"><div class="line"><span class="comment">// Initiate an asynchronous file copy</span></div>
<div class="line">data_movement_manager-&gt;initiateAsynchronousFileCopy(...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wait for an event</span></div>
<div class="line"><span class="keyword">auto</span> <span class="keyword">event</span> = this-&gt;waitForNextEvent();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">//Process the event</span></div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> file_copy_completion_event = std::dynamic_pointer_cast&lt;wrench::FileCopyCompletedEvent&gt;(event)) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;Notified of a file copy completion for file &quot;</span>;</div>
<div class="line">  std::cerr &lt;&lt; file_copy_completion_event-&gt;file-&gt;getID()&lt;&lt; <span class="stringliteral">&quot;as expected&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">   <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Unexpected event (&quot;</span> + event-&gt;toString() + <span class="stringliteral">&quot;)&quot;</span>);}</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="wrench-102-WMS-exceptions"></a>
Exceptions</h1>
<p>Most member functions in the WRENCH Developer API throw exceptions. In fact, most of the code fragments above should be in try-catch clauses, catching these exceptions.</p>
<p>Some exceptions correspond to failures during the simulated workflow executions (i.e., errors that would occur in a real-world execution and are thus part of the simulation). Each such exception contains a <code>wrench::FailureCause</code> object, which can be accessed to understand the root cause of the execution failure. Other exceptions (e.g., <code>std::invalid_arguments</code>, <code>std::runtime_error</code>) are thrown as well, which are used for detecting misuses of the WRENCH API or internal WRENCH errors.</p>
<h1><a class="anchor" id="wrench-102-WMS-hardware"></a>
Finding information and interacting with hardware resources</h1>
<p>The <code><a class="el" href="classwrench_1_1_simulation.html" title="A class that provides basic simulation methods. Once the simulation object has been explicitly or imp...">wrench::Simulation</a></code> class provides many member functions to discover information about the (simulated) hardware platform and interact with it. It also provides other useful information about the simulation itself, such as the current simulation date. Some of these member functions are static, but others are not. The <code>wrench:WMS</code> class includes a <code>simulation</code> object. Thus, the WMS can call member functions on the <code>this-&gt;simulation</code> object. For instance, this fragment of code shows how a WMS can figure out the current simulated date and then check that a host exists (given a hostname) and, if so, set its <code>pstate</code> (power state) to the highest possible setting.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> now = wrench::Simulation::getCurrentSimulatedDate();</div>
<div class="line"><span class="keywordflow">if</span> (wrench::Simulation::doesHostExist(<span class="stringliteral">&quot;SomeHost&quot;</span>))  {</div>
<div class="line">  this-&gt;simulation-&gt;setPstate(<span class="stringliteral">&quot;SomeHost&quot;</span>, <a class="code" href="classwrench_1_1_simulation.html#a5e8d5b963d2278c79b49a0ed7db2b933">wrench::Simulation::getNumberofPstates</a>(<span class="stringliteral">&quot;SomeHost&quot;</span>)-1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>See the documentation of the <code><a class="el" href="classwrench_1_1_simulation.html" title="A class that provides basic simulation methods. Once the simulation object has been explicitly or imp...">wrench::Simulation</a></code> class for all details. Specifically regarding host pstates, see the example WMS in <code>examples/basic-examples/cloud-bag-of-tasks-energy/TwoTasksAtATimeCloudWMS.cpp</code>, which interacts with host pstates (and the <code>examples/basic-examples/cloud-bag-of-tasks-energy/four_hosts_energy.xml</code> platform description file which defines pstates).</p>
<h1><a class="anchor" id="wrench-102-WMS-schedulers"></a>
Schedulers for decision-making</h1>
<p>A large part of what a WMS does is make decisions. It is often a good idea for decision-making algorithms (often simply called "scheduling
algorithms") to be re-usable across multiple WMS implementations, or plug-and-play-able for a single WMS implementation. For this reason, the <code><a class="el" href="classwrench_1_1_w_m_s.html" title="A workflow management system (WMS)">wrench::WMS</a></code> constructor takes as parameters two objects (or null pointers if not needed):</p>
<ul>
<li><code><a class="el" href="classwrench_1_1_standard_job_scheduler.html" title="A (mostly virtual) base class for implementing StandardJob scheduling algorithms to be used by a WMS.">wrench::StandardJobScheduler</a></code>: A class that has a <code><a class="el" href="classwrench_1_1_standard_job_scheduler.html#a97e8e3bef6e4eae41ff2996bc09ed2d9" title="A method that schedules tasks (as part of standard jobs), according to whatever decision algorithm it...">wrench::StandardJobScheduler::scheduleTasks()</a></code> member function (to be overwritten) that can be invoked at any time by the WMS to submit tasks (inside standard jobs) to compute services.</li>
<li><code><a class="el" href="classwrench_1_1_pilot_job_scheduler.html" title="A (mostly virtual) base class for implementing PilotJob scheduling algorithms to be used by a WMS.">wrench::PilotJobScheduler</a></code>: A class that has a <code>wrench::PilotJobScheduler::schedulePilotJobs()</code> member function (to be overwritten) that can be invoked at any time by the WMS to submit pilot jobs to compute services.</li>
</ul>
<p>Although not required, it is possible to implement most (or even all) decision-making in these two member functions so as to have a clean separation of concern between the decision-making part of the WMS and the rest of its functionality. This kind of design is used in the example simulators in the <code>examples/real-workflow-example/</code> directory.</p>
<h1><a class="anchor" id="wrench-102-WMS-logging"></a>
Logging</h1>
<p>It is typically desirable for the WMS to print log output to the terminal. This is easily accomplished using the <code>wrench::WRENCH_INFO()</code>, <code>wrench::WRENCH_DEBUG()</code>, and <code>wrench::WRENCH_WARN()</code> macros, which are used just like C's <code>printf()</code>. Each of these macros corresponds to a different logging level in SimGrid. See the <a href="https://simgrid.org/doc/latest/outcomes.html">SimGrid logging documentation</a> for all details.</p>
<p>Furthermore, one can change the color of the log messages with the <code>wrench::TerminalOutput::setThisProcessLoggingColor()</code> member function, which takes as parameter a color specification:</p>
<ul>
<li><code>wrench::TerminalOutput::COLOR_BLACK</code></li>
<li><code>wrench::TerminalOutput::COLOR_RED</code></li>
<li><code>wrench::TerminalOutput::COLOR_GREEN</code></li>
<li><code>wrench::TerminalOutput::COLOR_YELLOW</code></li>
<li><code>wrench::TerminalOutput::COLOR_BLUE</code></li>
<li><code>wrench::TerminalOutput::COLOR_MAGENTA</code></li>
<li><code>wrench::TerminalOutput::COLOR_CYAN</code></li>
<li><code>wrench::TerminalOutput::COLOR_WHITE</code></li>
</ul>
<p>When inspecting the code of the WMSs in the example simulators you will find many examples of calls to <code>wrench::WRENCH_INFO()</code>. The logging is per <code>.cpp</code> file, each of which corresponds to a declared logging category. For instance, in <code>examples/basic-examples/batch-bag-of-tasks/TwoTasksAtATimeBatchWMS.cpp</code>, you will find the typical pattern:</p>
<div class="fragment"><div class="line"><span class="comment">// Define a log category name for this file</span></div>
<div class="line">WRENCH_LOG_CATEGORY(custom_wms, <span class="stringliteral">&quot;Log category for TwoTasksAtATimeBatchWMS&quot;</span>);</div>
<div class="line"> </div>
<div class="line">[...]</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> TwoTasksAtATimeBatchWMS::main() {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the logging color to green</span></div>
<div class="line">  TerminalOutput::setThisProcessLoggingColor(TerminalOutput::COLOR_GREEN);</div>
<div class="line"> </div>
<div class="line">  [...]</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Print an info-level message, using printf-like format</span></div>
<div class="line">  WRENCH_INFO(<span class="stringliteral">&quot;Submitting the job, asking for %s %s-core nodes for %s minutes&quot;</span>,</div>
<div class="line">              service_specific_arguments[<span class="stringliteral">&quot;-N&quot;</span>].c_str(),</div>
<div class="line">              service_specific_arguments[<span class="stringliteral">&quot;-c&quot;</span>].c_str(),</div>
<div class="line">              service_specific_arguments[<span class="stringliteral">&quot;-t&quot;</span>].c_str());</div>
<div class="line"> </div>
<div class="line">  [...]</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Print a last info-level message </span></div>
<div class="line">  WRENCH_INFO(<span class="stringliteral">&quot;Workflow execution complete&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The name of the logging category, in this case <code>custom_wms</code>, can then be passed to the <code>--log</code> command-line argument. For instance, invoking the simulator with additional argument <code>--log=custom_wms.threshold=info</code> will make it so that only those <code>WRENCH_INFO</code> statements in <code>TwoTasksAtATimeBatchWMS.cpp</code> will be printed (in green!). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclasswrench_1_1_simulation_html_a5e8d5b963d2278c79b49a0ed7db2b933"><div class="ttname"><a href="classwrench_1_1_simulation.html#a5e8d5b963d2278c79b49a0ed7db2b933">wrench::Simulation::getNumberofPstates</a></div><div class="ttdeci">static int getNumberofPstates(const std::string &amp;hostname)</div><div class="ttdoc">Get the total number of power states of a host.</div><div class="ttdef"><b>Definition:</b> Simulation.cpp:1221</div></div>
<div class="ttc" id="aclasswrench_1_1_workflow_file_html"><div class="ttname"><a href="classwrench_1_1_workflow_file.html">wrench::WorkflowFile</a></div><div class="ttdoc">A data file used/produced by a WorkflowTask in a Workflow.</div><div class="ttdef"><b>Definition:</b> WorkflowFile.h:26</div></div>
<div class="footer">
    <div style="float: left; width: 40%; padding-left: 2em; padding-bottom: 4em !important;">
        <p style="font-size: 0.8em"><strong>&copy;2017-2021 WRENCH. All Rights Reserved.</strong><br/></p>
        <p style="padding-top: 1em">
            <a href="mailto:support@wrench-project.org" class="fa-stack fa-2x" style="font-size: 1.5em">
                <i class="fa fa-circle fa-stack-2x icon-background"></i>
                <i class="fa fa-envelope fa-stack-1x"></i>
            </a>
            <a href="https://twitter.com/wrenchproject" target="_blank" class="fa-stack fa-2x"
               style="font-size: 1.5em">
                <i class="fa fa-circle fa-stack-2x icon-background"></i>
                <i class="fab fa-twitter fa-stack-1x"></i>
            </a>
            <a href="https://github.com/wrench-project/wrench" target="_blank" class="fa-stack fa-2x"
               style="font-size: 1.5em">
                <i class="fa fa-circle fa-stack-2x icon-background"></i>
                <i class="fab fa-github fa-stack-1x"></i>
            </a>
        </p>
    </div>
    <div style="float: right; width: 40%; padding-right: 2em">
        <p style="font-size: 0.8em">
            WRENCH is funded by the National Science Foundation (NSF) under grants number <a
                href="https://nsf.gov/awardsearch/showAward?AWD_ID=2103489" target="_blank">2103489</a>,
            <a href="https://nsf.gov/awardsearch/showAward?AWD_ID=2103508" target="_blank">2103508</a>,
            <a href="https://nsf.gov/awardsearch/showAward?AWD_ID=1923539" target="_blank">1923539</a>, and
            <a href="https://nsf.gov/awardsearch/showAward?AWD_ID=1923621" target="_blank">1923621</a>;
            and the National Center for Scientific Research (CNRS) under grant number PICS07239.
        </p>
        <p style="font-weight: normal; font-size: 0.7em; margin-top: 1em">
            Any opinions, findings, and conclusions or recommendations expressed in this material are those
            of the author(s) and do not necessarily reflect the views of the National Science Foundation.
        </p>
    </div>
</div>
<!-- add the button to toggle the theme -->
<script>
    $(document).ready(function () {
        toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
        toggleButton.title = "Toggle Light/Dark Mode"
        document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
</script>
<!-- Google Analytics -->
<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
            m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-18066333-6', 'auto');
    ga('send', 'pageview');
</script>
</body>
</html>
