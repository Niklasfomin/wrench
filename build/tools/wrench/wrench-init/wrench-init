#!/usr/bin/env python3
#
# Copyright (c) 2019-2021. The WRENCH Team.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
FILE_CONTENT_FINDSIMGRID_CMAKE = r"""
# CMake find module to search for the SimGrid library.

# Copyright (c) 2016-2022. The SimGrid Team.
#
# This file is free software; you can redistribute it and/or modify it
# under the terms of the license (GNU LGPL) which comes with this package.

#
# USERS OF PROGRAMS USING SIMGRID
# -------------------------------
#
# If cmake does not find this file, add its path to CMAKE_PREFIX_PATH:
#    CMAKE_PREFIX_PATH="/path/to/FindSimGrid.cmake:$CMAKE_PREFIX_PATH"  cmake .
#
# If this file does not find SimGrid, define SimGrid_PATH:
#    SimGrid_PATH=/path/to/simgrid  cmake .

#
# DEVELOPERS OF PROGRAMS USING SIMGRID
# ------------------------------------
#
#  1. Include this file in your own CMakeLists.txt (before defining any target)
#     Either by copying it in your tree, or (recommended) by using the
#     version automatically installed by SimGrid.
#
#  2. Afterward, if you have CMake >= 2.8.12, this will define a
#     target called 'SimGrid::Simgrid'. Use it as:
#       target_link_libraries(your-simulator SimGrid::SimGrid)
#
#    With older CMake (< 2.8.12), it simply defines several variables:
#       SimGrid_INCLUDE_DIR - the SimGrid include directories
#       SimGrid_LIBRARY - link your simulator against it to use SimGrid
#    Use as:
#      include_directories("${SimGrid_INCLUDE_DIR}" SYSTEM)
#      target_link_libraries(your-simulator ${SimGrid_LIBRARY})
#
#  In both cases, it also define a SimGrid_VERSION macro, that you
#    can use to deal with API evolutions as follows:
#
#    #if SimGrid_VERSION < 31800
#      (code to use if the installed version is lower than v3.18)
#    #elif SimGrid_VERSION < 31900
#      (code to use if we are using SimGrid v3.18.x)
#    #else
#      (code to use with SimGrid v3.19+)
#    #endif
#
#  Since SimGrid header files require C++14, so we set CMAKE_CXX_STANDARD to 14.
#    Change this variable in your own file if you need a later standard.

#
# IMPROVING THIS FILE
# -------------------
#  - Use automatic SimGridConfig.cmake creation via export/install(EXPORT in main CMakeLists.txt:
#    https://cliutils.gitlab.io/modern-cmake/chapters/exporting.html
#    https://cmake.org/Wiki/CMake/Tutorials/How_to_create_a_ProjectConfig.cmake_file
#    https://github.com/boostcon/cppnow_presentations_2017/blob/master/05-19-2017_friday/effective_cmake__daniel_pfeifer__cppnow_05-19-2017.pdf

cmake_minimum_required(VERSION 2.8.12)

set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_path(SimGrid_INCLUDE_DIR
  NAMES simgrid/config.h
  NAMES simgrid/version.h
  PATHS ${SimGrid_PATH}/include /opt/simgrid/include
)
if (NOT SimGrid_INCLUDE_DIR)
  # search under the old name
  find_path(SimGrid_INCLUDE_DIR
    NAMES simgrid_config.h
    PATHS ${SimGrid_PATH}/include /opt/simgrid/include
  )
endif()
find_library(SimGrid_LIBRARY
  NAMES simgrid
  PATHS ${SimGrid_PATH}/lib /opt/simgrid/lib
)
mark_as_advanced(SimGrid_INCLUDE_DIR)
mark_as_advanced(SimGrid_LIBRARY)

if (SimGrid_INCLUDE_DIR)
  set(SimGrid_VERSION_REGEX "^#define SIMGRID_VERSION_(MAJOR|MINOR|PATCH) ([0-9]+)$")
  if (EXISTS "${SimGrid_INCLUDE_DIR}/simgrid/version.h")
    file(STRINGS "${SimGrid_INCLUDE_DIR}/simgrid/version.h" SimGrid_VERSION_STRING REGEX ${SimGrid_VERSION_REGEX})
  elseif (EXISTS "${SimGrid_INCLUDE_DIR}/simgrid/config.h")
    file(STRINGS "${SimGrid_INCLUDE_DIR}/simgrid/config.h" SimGrid_VERSION_STRING REGEX ${SimGrid_VERSION_REGEX})
  else()
    file(STRINGS "${SimGrid_INCLUDE_DIR}/simgrid_config.h" SimGrid_VERSION_STRING REGEX ${SimGrid_VERSION_REGEX})
  endif()
  set(SimGrid_VERSION "")

  # Concat the matches to MAJOR.MINOR.PATCH assuming they appear in this order
  foreach(match ${SimGrid_VERSION_STRING})
    if(SimGrid_VERSION)
      set(SimGrid_VERSION "${SimGrid_VERSION}.")
    endif()
    string(REGEX REPLACE ${SimGrid_VERSION_REGEX} "${SimGrid_VERSION}\\2" SimGrid_VERSION ${match})
    set(SimGrid_VERSION_${CMAKE_MATCH_1} ${CMAKE_MATCH_2})
  endforeach()
  unset(SimGrid_VERSION_STRING)
  unset(SimGrid_VERSION_REGEX)
endif ()

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(SimGrid
  FOUND_VAR SimGrid_FOUND
  REQUIRED_VARS SimGrid_INCLUDE_DIR SimGrid_LIBRARY
  VERSION_VAR SimGrid_VERSION
)

if (SimGrid_FOUND AND NOT CMAKE_VERSION VERSION_LESS 2.8.12)
  add_library(SimGrid::SimGrid SHARED IMPORTED)
  set_target_properties(SimGrid::SimGrid PROPERTIES
    INTERFACE_SYSTEM_INCLUDE_DIRECTORIES ${SimGrid_INCLUDE_DIR}
    INTERFACE_COMPILE_FEATURES cxx_alias_templates
    IMPORTED_LOCATION ${SimGrid_LIBRARY}
  )
  # We need C++14, so check for it just in case the user removed it since compiling SimGrid
  if (NOT CMAKE_VERSION VERSION_LESS 3.8)
    # 3.8+ allows us to simply require C++14 (or higher)
    set_property(TARGET SimGrid::SimGrid PROPERTY INTERFACE_COMPILE_FEATURES cxx_std_14)
  elseif (NOT CMAKE_VERSION VERSION_LESS 3.1)
    # 3.1+ is similar but for certain features. We pick just one
    set_property(TARGET SimGrid::SimGrid PROPERTY INTERFACE_COMPILE_FEATURES cxx_attribute_deprecated)
  else ()
    # Old CMake can't do much. Just check the CXX_FLAGS and inform the user when a C++14 feature does not work
    include(CheckCXXSourceCompiles)
    set(CMAKE_REQUIRED_FLAGS "${CMAKE_CXX_FLAGS}")
    check_cxx_source_compiles("
#if __cplusplus < 201402L
#error
#else
int main(){}
#endif
" _SIMGRID_CXX14_ENABLED)
    if (NOT _SIMGRID_CXX14_ENABLED)
        message(WARNING "C++14 is required to use SimGrid. Enable it with e.g. -std=c++14")
    endif ()
    unset(_SIMGRID_CXX14_ENABLED CACHE)
  endif ()
endif ()

"""

FILE_CONTENT_FINDWRENCH_CMAKE = r"""
# CMake find module to search for the WRENCH library.

# Copyright (c) 2022. The WRENCH Team.
#
# This file is free software; you can redistribute it and/or modify it
# under the terms of the license (GNU LGPL) which comes with this package.

#
# USERS OF PROGRAMS USING WRENCH
# -------------------------------
#
# If cmake does not find this file, add its path to CMAKE_PREFIX_PATH:
#    CMAKE_PREFIX_PATH="/path/to/FindWRENCH.cmake:$CMAKE_PREFIX_PATH"  cmake .
#
# If this file does not find WRENCH, define WRENCH_PATH:
#    WRENCH_PATH=/path/to/wrench cmake .

#
# DEVELOPERS OF PROGRAMS USING WRENCH
# ------------------------------------
#
#  1. Include this file in your own CMakeLists.txt (before defining any target)
#     by copying it in your development tree. 
#
#  2. Afterward, if you have CMake >= 2.8.12, this will define a
#     target called 'WRENCH::WRENCH'. Use it as:
#       target_link_libraries(your-simulator WRENCH::WRENCH)
#
#    With older CMake (< 2.8.12), it simply defines several variables:
#       WRENCH_INCLUDE_DIR - the WRENCH include directories
#       WRENCH_LIBRARY - link your simulator against it to use WRENCH
#    Use as:
#      include_directories("${WRENCH_INCLUDE_DIR}" SYSTEM)
#      target_link_libraries(your-simulator ${WRENCH_LIBRARY})
#
#  Since WRENCH header files require C++14, so we set CMAKE_CXX_STANDARD to 14.
#    Change this variable in your own file if you need a later standard.

cmake_minimum_required(VERSION 2.8.12)

set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_path(WRENCH_INCLUDE_DIR
        NAMES wrench-dev.h
        PATHS ${WRENCH_PATH}/include /opt/wrench/include
        )

find_library(WRENCH_LIBRARY
        NAMES wrench
        PATHS ${WRENCH_PATH}/lib /opt/wrench/lib
        )

    find_library(WRENCH_WFCOMMONS_WORKFLOW_PARSER_LIBRARY
        NAMES wrenchwfcommonsworkflowparser
        PATHS ${WRENCH_PATH}/lib /opt/wrench/lib
        )


mark_as_advanced(WRENCH_INCLUDE_DIR)
mark_as_advanced(WRENCH_LIBRARY)
mark_as_advanced(WRENCH_WFCOMMONS_WORKFLOW_PARSER_LIBRARY)


include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(WRENCH
        FOUND_VAR WRENCH_FOUND
        REQUIRED_VARS WRENCH_INCLUDE_DIR WRENCH_LIBRARY WRENCH_WFCOMMONS_WORKFLOW_PARSER_LIBRARY
        VERSION_VAR WRENCH_VERSION
        REASON_FAILURE_MESSAGE "The WRENCH package could not be located. If you installed WRENCH in a non-standard location, pass -DWRENCH_PATH=<path to location> to cmake (e.g., cmake -DWRENCH_PATH=/opt/somewhere/)"
        FAIL_MESSAGE "Could not find the WRENCH installation"
        )


if (WRENCH_FOUND AND NOT CMAKE_VERSION VERSION_LESS 2.8.12)

    add_library(WRENCH::WRENCH SHARED IMPORTED)
    set_target_properties(WRENCH::WRENCH PROPERTIES
            INTERFACE_SYSTEM_INCLUDE_DIRECTORIES ${WRENCH_INCLUDE_DIR}
            INTERFACE_COMPILE_FEATURES cxx_alias_templates
            IMPORTED_LOCATION ${WRENCH_LIBRARY}
            )
    # We need C++14, so check for it just in case the user removed it since compiling WRENCH
    if (NOT CMAKE_VERSION VERSION_LESS 3.8)
        # 3.8+ allows us to simply require C++14 (or higher)
        set_property(TARGET WRENCH::WRENCH PROPERTY INTERFACE_COMPILE_FEATURES cxx_std_14)
    elseif (NOT CMAKE_VERSION VERSION_LESS 3.1)
        # 3.1+ is similar but for certain features. We pick just one
        set_property(TARGET WRENCH::WRENCH PROPERTY INTERFACE_COMPILE_FEATURES cxx_attribute_deprecated)
    else ()
        # Old CMake can't do much. Just check the CXX_FLAGS and inform the user when a C++14 feature does not work
        include(CheckCXXSourceCompiles)
        set(CMAKE_REQUIRED_FLAGS "${CMAKE_CXX_FLAGS}")
        check_cxx_source_compiles("
#if __cplusplus < 201402L
#error
#else
int main(){}
#endif
" _WRENCH_CXX14_ENABLED)
        if (NOT _WRENCH_CXX14_ENABLED)
            message(WARNING "C++14 is required to use WRENCH. Enable it with e.g. -std=c++14")
        endif ()
        unset(_WRENCH_CXX14_ENABLED CACHE)
    endif ()
endif ()

"""

FILE_CONTENT_CMAKELISTS_TXT = r"""
cmake_minimum_required(VERSION 3.2)
message(STATUS "Cmake version ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}")

project(my-wrench-simulator)

# Disable annoying warnings
add_definitions("-DBOOST_ALLOW_DEPRECATED_HEADERS")
#add_definitions("-DBOOST_BIND_GLOBAL_PLACEHOLDERS")

add_definitions("-Wall -Wno-unused-variable -Wno-unused-private-field")

set(CMAKE_CXX_STANDARD 17)

set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/CMakeModules/")

# Find WRENCH, SimGrid, and Boost
find_package(WRENCH REQUIRED)
find_package(SimGrid REQUIRED)
find_package(Boost REQUIRED)

# include directories
include_directories(include/ /usr/local/include/ /opt/local/include/ ${WRENCH_INCLUDE_DIR} ${SimGrid_INCLUDE_DIR} ${Boost_INCLUDE_DIR})

# source files
set(SOURCE_FILES
        include/Controller.h
        src/Controller.cpp
        src/Simulator.cpp
        )

# generating the executable
add_executable(my-wrench-simulator ${SOURCE_FILES})

# Specify libraries to link
if (ENABLE_BATSCHED)
    target_link_libraries(my-wrench-simulator
            ${WRENCH_LIBRARY}
            ${SimGrid_LIBRARY}
            ${Boost_LIBRARIES}
            ${WRENCH_WFCOMMONS_WORKFLOW_PARSER_LIBRARY}
            -lzmq)
else()
    target_link_libraries(my-wrench-simulator
            ${WRENCH_LIBRARY}
            ${SimGrid_LIBRARY}
            ${Boost_LIBRARIES}
            ${WRENCH_WFCOMMONS_WORKFLOW_PARSER_LIBRARY}
            )
endif()

install(TARGETS my-wrench-simulator DESTINATION bin)
"""

FILE_CONTENT_SIMULATOR_WORKFLOW_CPP = r"""
/**
 * Copyright (c) 2017-2021. The WRENCH Team.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */

/**
 ** This is the main function for a WRENCH simulator. The simulator takes
 ** a input an XML platform description file. It generates a workflow with
 ** a simple diamond structure, instantiates a few services on the platform, and
 ** starts an execution controller to execute the workflow using these services
 ** using a simple greedy algorithm.
 **/

#define GFLOP (1000.0 * 1000.0 * 1000.0)
#define MBYTE (1000.0 * 1000.0)
#define GBYTE (1000.0 * 1000.0 * 1000.0)

#include <iostream>
#include <wrench-dev.h>

#include "Controller.h"

/**
 * @brief The Simulator's main function
 *
 * @param argc: argument count
 * @param argv: argument array
 * @return 0 on success, non-zero otherwise
 */
int main(int argc, char **argv) {

    /* Create a WRENCH simulation object */
    auto simulation = wrench::Simulation::createSimulation();

    /* Initialize the simulation */
    simulation->init(&argc, argv);

    /* Parsing of the command-line arguments */
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <xml platform file> [--log=controller.threshold=info | --wrench-full-log]" << std::endl;
        exit(1);
    }

    /* Instantiating the simulated platform */
    simulation->instantiatePlatform(argv[1]);

    /* Create a workflow */
    auto workflow = wrench::Workflow::createWorkflow();

    /* Add a workflow task. See examples in the examples/workflow_api/
     * directory for examples of how to create various workflows */
    auto task1 = workflow->addTask("task1", 10 * GFLOP, 2, 10, 2 * GBYTE);
    auto task2 = workflow->addTask("task2", 40 * GFLOP, 2, 10, 4 * GBYTE);
    auto task3 = workflow->addTask("task3", 30 * GFLOP, 2, 10, 4 * GBYTE);
    auto task4 = workflow->addTask("task4", 20 * GFLOP, 2, 10, 2 * GBYTE);

    /* Set a custom parallel efficiency behavior for task 2 */
    task2->setParallelModel(wrench::ParallelModel::AMDAHL(0.8));

    /* Create a couple of workflow files */
    auto task1_input = workflow->addFile("task1_input", 50 * MBYTE);
    auto task1_output = workflow->addFile("task1_output", 20 * MBYTE);
    task1->addInputFile(task1_input);
    task1->addOutputFile(task1_output);
    auto task2_output = workflow->addFile("task2_output", 30 * MBYTE);
    task2->addOutputFile(task2_output);

    /* Create data/control dependencies
     *
     *       task1
     *      /     \
     *   task2   task3
     *      \     /
     *       task4
     */
    workflow->addControlDependency(task1, task2);
    task3->addInputFile(task1_output);
    workflow->addControlDependency(task3, task4);
    task4->addInputFile(task2_output);

    /* Instantiate a storage service on the platform */
    auto storage_service = simulation->add(wrench::SimpleStorageService::createSimpleStorageService(
            "StorageHost", {"/"}, {}, {}));

    /* Instantiate a bare-metal compute service on the platform */
    auto baremetal_service = simulation->add(new wrench::BareMetalComputeService(
            "ComputeHost", {"ComputeHost"}, "", {}, {}));

    /* Instantiate an execution controller */
    auto wms = simulation->add(
            new wrench::Controller(workflow, baremetal_service, storage_service, "UserHost"));

    /* Instantiate a file registry service */
    auto file_registry_service = new wrench::FileRegistryService("UserHost");
    simulation->add(file_registry_service);

    /* Stage input files on the storage service */
    for (auto const &f: workflow->getInputFiles()) {
        simulation->stageFile(f, storage_service);
    }

    /* Launch the simulation */
    simulation->launch();

    /* Print task execution timelines */
    std::vector<std::shared_ptr<wrench::WorkflowTask>> tasks = {task1, task2, task3, task4};
    for (auto const &t: tasks) {
        printf("Task %s: %.2fs - %.2fs\n", t->getID().c_str(), t->getStartDate(), t->getEndDate());
    }

    return 0;
}
"""

FILE_CONTENT_CONTROLLER_WORKFLOW_CPP = r"""
/**
 * Copyright (c) 2017-2021. The WRENCH Team.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */

/**
 ** An execution controller to execute a workflow
 **/

#include <iostream>

#include "Controller.h"

WRENCH_LOG_CATEGORY(controller, "Log category for Controller");

namespace wrench {

    /**
     * @brief Constructor
     *
     * @param workflow: the workflow to execute
     * @param bare_metal_compute_service: a set of compute services available to run tasks
     * @param storage_services: a set of storage services available to store files
     * @param hostname: the name of the host on which to start the WMS
     */
    Controller::Controller(std::shared_ptr<Workflow> workflow,
                           const std::shared_ptr<BareMetalComputeService> &bare_metal_compute_service,
                           const std::shared_ptr<SimpleStorageService> &storage_service,
                           const std::string &hostname) : ExecutionController(hostname, "controller"),
                                                          workflow(workflow), bare_metal_compute_service(bare_metal_compute_service), storage_service(storage_service) {}

    /**
     * @brief main method of the Controller
     *
     * @return 0 on completion
     *
     * @throw std::runtime_error
     */
    int Controller::main() {

        /* Set the logging output to GREEN */
        TerminalOutput::setThisProcessLoggingColor(TerminalOutput::COLOR_GREEN);

        WRENCH_INFO("Controller starting");
        WRENCH_INFO("About to execute a workflow with %lu tasks", this->workflow->getNumberOfTasks());

        /* Create a job manager so that we can create/submit jobs */
        auto job_manager = this->createJobManager();

        /* While the workflow isn't done, repeat the main loop */
        while (not this->workflow->isDone()) {

            /* Submit each ready task as a single job */
            int num_job_submitted = 0;
            auto ready_tasks = this->workflow->getReadyTasks();
            for (auto const &ready_task: ready_tasks) {
                /* Create a standard job for the task */
                WRENCH_INFO("Creating a job for task %s", ready_task->getID().c_str());

                /* Create a map of file locations, stating for each file (could be none)
                 * where it should be read/written */
                std::map<std::shared_ptr<DataFile>, std::shared_ptr<FileLocation>> file_locations;
                for (auto const &f: ready_task->getInputFiles()) {
                    file_locations[f] = FileLocation::LOCATION(storage_service, f);
                }
                for (auto const &f: ready_task->getOutputFiles()) {
                    file_locations[f] = FileLocation::LOCATION(storage_service, f);
                }

                /* Create the job  */
                auto standard_job = job_manager->createStandardJob(ready_task, file_locations);

                /* Submit the job to the compute service */
                WRENCH_INFO("Submitting the job to the compute service");
                job_manager->submitJob(standard_job, bare_metal_compute_service);
            }

            /* Wait for a workflow execution event and process it */
            this->waitForAndProcessNextEvent();
        }

        WRENCH_INFO("Workflow execution complete!");
        return 0;
    }

    /**
     * @brief Process a standard job completion event
     *
     * @param event: the event
     */
    void Controller::processEventStandardJobCompletion(std::shared_ptr<StandardJobCompletedEvent> event) {
        /* Retrieve the job that this event is for */
        auto job = event->standard_job;
        /* Retrieve the job's first (and in our case only) task */
        auto task = job->getTasks().at(0);
        WRENCH_INFO("Notified that a standard job has completed task %s", task->getID().c_str());
    }
}// namespace wrench
"""

FILE_CONTENT_CONTROLLER_WORKFLOW_H = r"""
/**
 * Copyright (c) 2017-2018. The WRENCH Team.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */


#ifndef CONTROLLER_H
#define CONTROLLER_H

#include <wrench-dev.h>

namespace wrench {

    /**
     *  @brief A Workflow Management System (WMS) implementation
     */
    class Controller : public ExecutionController {

    public:
        // Constructor
        Controller(
                std::shared_ptr<Workflow> workflow,
                const std::shared_ptr<BareMetalComputeService> &bare_metal_compute_service,
                const std::shared_ptr<SimpleStorageService> &storage_service,
                const std::string &hostname);

    protected:
        // Overridden method
        void processEventStandardJobCompletion(std::shared_ptr<StandardJobCompletedEvent>) override;

    private:
        // main() method of the WMS
        int main() override;

        std::shared_ptr<Workflow> workflow;
        const std::shared_ptr<BareMetalComputeService> bare_metal_compute_service;
        const std::shared_ptr<SimpleStorageService> storage_service;
    };
}// namespace wrench
#endif//CONTROLLER_H
"""

FILE_CONTENT_SIMULATOR_ACTION_CPP = r"""
/**
 * Copyright (c) 2017-2021. The WRENCH Team.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */

/**
 ** This is the main function for a WRENCH simulator. The simulator takes
 ** a input an XML platform description file. It generates a workflow with
 ** a simple diamond structure, instantiates a few services on the platform, and
 ** starts an execution controller to execute the workflow using these services
 ** using a simple greedy algorithm.
 **/

#include <iostream>
#include <wrench-dev.h>

#include "Controller.h"

/**
 * @brief The Simulator's main function
 *
 * @param argc: argument count
 * @param argv: argument array
 * @return 0 on success, non-zero otherwise
 */
int main(int argc, char **argv) {

    /* Create a WRENCH simulation object */
    auto simulation = wrench::Simulation::createSimulation();

    /* Initialize the simulation */
    simulation->init(&argc, argv);

    /* Parsing of the command-line arguments */
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <xml platform file> [--log=controller.threshold=info | --wrench-full-log]" << std::endl;
        exit(1);
    }

    /* Instantiating the simulated platform */
    simulation->instantiatePlatform(argv[1]);

    /* Instantiate a storage service on the platform */
    auto storage_service = simulation->add(wrench::SimpleStorageService::createSimpleStorageService(
            "StorageHost", {"/"}, {}, {}));

    /* Instantiate a bare-metal compute service on the platform */
    auto baremetal_service = simulation->add(new wrench::BareMetalComputeService(
            "ComputeHost", {"ComputeHost"}, "", {}, {}));

    /* Instantiate an execution controller */
    auto controller = simulation->add(
            new wrench::Controller(baremetal_service, storage_service, "UserHost"));

    /* Launch the simulation */
    simulation->launch();

    return 0;
}
"""

FILE_CONTENT_CONTROLLER_ACTION_CPP = r"""
/**
 * Copyright (c) 2017-2021. The WRENCH Team.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */

/**
 ** An execution controller to execute a workflow
 **/

#define GFLOP (1000.0 * 1000.0 * 1000.0)
#define MBYTE (1000.0 * 1000.0)
#define GBYTE (1000.0 * 1000.0 * 1000.0)

#include <iostream>

#include "Controller.h"

WRENCH_LOG_CATEGORY(controller, "Log category for Controller");

namespace wrench {

    /**
     * @brief Constructor
     *
     * @param bare_metal_compute_service: a set of compute services available to run actions
     * @param storage_services: a set of storage services available to store files
     * @param hostname: the name of the host on which to start the WMS
     */
    Controller::Controller(const std::shared_ptr<BareMetalComputeService> &bare_metal_compute_service,
                           const std::shared_ptr<SimpleStorageService> &storage_service,
                           const std::string &hostname) : ExecutionController(hostname, "controller"),
                                                          bare_metal_compute_service(bare_metal_compute_service), storage_service(storage_service) {}

    /**
     * @brief main method of the Controller
     *
     * @return 0 on completion
     *
     * @throw std::runtime_error
     */
    int Controller::main() {

        /* Set the logging output to GREEN */
        TerminalOutput::setThisProcessLoggingColor(TerminalOutput::COLOR_GREEN);
        WRENCH_INFO("Controller starting");

        /* Create a files */
        auto some_file = wrench::Simulation::addFile("some_file", 1 * GBYTE);
        auto some_other_file = wrench::Simulation::addFile("some_other_file", 2 * GBYTE);
        wrench::StorageService::createFileAtLocation(wrench::FileLocation::LOCATION(this->storage_service, some_file));

        /* Create a job manager so that we can create/submit jobs */
        auto job_manager = this->createJobManager();

        WRENCH_INFO("Creating a compound job with a file read action followed by a compute action");
        auto job1 = job_manager->createCompoundJob("job1");
        auto fileread = job1->addFileReadAction("fileread", wrench::FileLocation::LOCATION(this->storage_service, some_file));
        auto compute = job1->addComputeAction("compute", 100 * GFLOP, 50 * MBYTE, 1, 3, wrench::ParallelModel::AMDAHL(0.8));
        job1->addActionDependency(fileread, compute);

        WRENCH_INFO("Creating a compound job with a file write action and a (simultaneous) sleep action");
        auto job2 = job_manager->createCompoundJob("job2");
        auto filewrite = job2->addFileWriteAction("filewrite", wrench::FileLocation::LOCATION(this->storage_service, some_other_file));
        auto sleep = job2->addSleepAction("sleep", 20.0);

        WRENCH_INFO("Making the second job depend on the first one");
        job2->addParentJob(job1);

        WRENCH_INFO("Submitting both jobs to the bare-metal compute service");

        job_manager->submitJob(job1, this->bare_metal_compute_service);
        job_manager->submitJob(job2, this->bare_metal_compute_service);

        WRENCH_INFO("Waiting for an execution event...");
        this->waitForAndProcessNextEvent();
        WRENCH_INFO("Waiting for an execution event...");
        this->waitForAndProcessNextEvent();

        WRENCH_INFO("Execution complete!");

        std::vector<std::shared_ptr<wrench::Action>> actions = {fileread, compute, filewrite, sleep};
        for (auto const &a: actions) {
            printf("Action %s: %.2fs - %.2fs\n", a->getName().c_str(), a->getStartDate(), a->getEndDate());
        }

        return 0;
    }

    /**
     * @brief Process a compound job completion event
     *
     * @param event: the event
     */
    void Controller::processEventCompoundJobCompletion(std::shared_ptr<CompoundJobCompletedEvent> event) {
        /* Retrieve the job that this event is for */
        auto job = event->job;
        /* Print info about all actions in the job */
        WRENCH_INFO("Notified that compound job %s has completed:", job->getName().c_str());
    }
}// namespace wrench
"""

FILE_CONTENT_CONTROLLER_ACTION_H = r"""
/**
 * Copyright (c) 2017-2018. The WRENCH Team.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */


#ifndef CONTROLLER_H
#define CONTROLLER_H

#include <wrench-dev.h>

namespace wrench {

    /**
     *  @brief A Workflow Management System (WMS) implementation
     */
    class Controller : public ExecutionController {

    public:
        // Constructor
        Controller(
                const std::shared_ptr<BareMetalComputeService> &bare_metal_compute_service,
                const std::shared_ptr<SimpleStorageService> &storage_service,
                const std::string &hostname);

    protected:
        // Overridden method
        void processEventCompoundJobCompletion(std::shared_ptr<CompoundJobCompletedEvent>) override;

    private:
        // main() method of the WMS
        int main() override;

        const std::shared_ptr<BareMetalComputeService> bare_metal_compute_service;
        const std::shared_ptr<SimpleStorageService> storage_service;
    };
}// namespace wrench
#endif//CONTROLLER_H
"""

FILE_CONTENT_PLATFORM_XML = r"""
<?xml version='1.0'?>
<!DOCTYPE platform SYSTEM "https://simgrid.org/simgrid.dtd">
<platform version="4.1">
    <zone id="AS0" routing="Full">

        <!-- The host on which the WMS will run -->
        <host id="UserHost" speed="10Gf" core="1">
        </host>

        <!-- The host on which the WMS will run -->
        <host id="StorageHost" speed="10Gf" core="1">
            <disk id="hard_drive" read_bw="100MBps" write_bw="100MBps">
                <prop id="size" value="5000GiB"/>
                <prop id="mount" value="/"/>
            </disk>
        </host>

        <!-- The host on which the bare-metal compute service will run -->
        <host id="ComputeHost" speed="1Gf" core="10">
            <prop id="ram" value="16GB" />
       </host>

        <!-- A network link that connects both hosts -->
        <link id="shared_network" bandwidth="50MBps" latency="20us"/>

        <!-- Network routes -->
        <route src="UserHost" dst="ComputeHost">
            <link_ctn id="shared_network"/>
        </route>
        <route src="UserHost" dst="StorageHost">
            <link_ctn id="shared_network"/>
        </route>
        <route src="StorageHost" dst="ComputeHost">
            <link_ctn id="shared_network"/>
        </route>

    </zone>
</platform>
"""


import argparse
import logging
import os
import shutil

logger = logging.getLogger(__name__)

def _configure_logging(debug):
    """
    Configure the application's logging.
    :param debug: whether debugging is enabled
    """
    if debug:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

def _create_subdirectories(project_dir):
    """
    Create the subdirectories for the project
    :param project_dir: project directory
    """
    logger.debug('Creating subdirectories structure')
    sub_dirs = ['CMakeModules', 'src', 'include', 'build', 'data']
    for sub_dir in sub_dirs:
        if not os.path.isdir(project_dir + '/' + sub_dir):
            os.mkdir(project_dir + '/' + sub_dir)
            logger.debug('  Created subdirectory: %s' % project_dir + '/' + sub_dir)

def _create_file(content, file_path):
    ascii_file = open(file_path, "w")
    ascii_file.write(content)
    ascii_file.close()

def main():
    # Application's arguments
    parser = argparse.ArgumentParser(description='Create a skeleton for a WRENCH-based simulator source code.')
    parser.add_argument('project_dir', metavar='PROJECT_DIR', help='Project directory name')
    parser.add_argument('-a', '--api', action='store', metavar='API',
                        help='Specify which API (action or workflow)', default='action')
    parser.add_argument('-d', '--debug', action='store_true', help='Print debug messages to stderr')
    parser.add_argument('-f', '--force', action='store_true',
                        help='Overwrites existing project directory (use sparingly)')
    args = parser.parse_args()

    # Configure logging
    _configure_logging(args.debug)

    # Sanity check
    if os.path.isdir(args.project_dir) and not args.force:
        logger.error('The provided project directory already exists:\n\t%s\nUse --force to overwrite the directory' \
                     % args.project_dir)
        exit(1)

    if args.api:
        args.api = args.api.lower()
        if args.api not in ['action', 'workflow']:
            logger.error('Invalid API specification: %s' % args.api)
            exit(1)

    logger.info('Creating WRENCH skeleton project at: %s' % args.project_dir)

    if not os.path.isdir(args.project_dir):
        os.mkdir(args.project_dir)

    # subdirectories structure
    _create_subdirectories(args.project_dir)

    # Copy all relevant files
    _create_file(FILE_CONTENT_CMAKELISTS_TXT, args.project_dir + "/CMakeLists.txt")
    _create_file(FILE_CONTENT_FINDSIMGRID_CMAKE, args.project_dir + "/CMakeModules/FindSimGrid.cmake")
    _create_file(FILE_CONTENT_FINDWRENCH_CMAKE, args.project_dir + "/CMakeModules/FindWRENCH.cmake")
    _create_file(FILE_CONTENT_PLATFORM_XML, args.project_dir + "/data/platform.xml")

    if (args.api == "workflow"):
        _create_file(FILE_CONTENT_SIMULATOR_WORKFLOW_CPP, args.project_dir + "/src/Simulator.cpp")
        _create_file(FILE_CONTENT_CONTROLLER_WORKFLOW_CPP, args.project_dir + "/src/Controller.cpp")
        _create_file(FILE_CONTENT_CONTROLLER_WORKFLOW_H, args.project_dir + "/include/Controller.h")
    else:
        _create_file(FILE_CONTENT_SIMULATOR_ACTION_CPP, args.project_dir + "/src/Simulator.cpp")
        _create_file(FILE_CONTENT_CONTROLLER_ACTION_CPP, args.project_dir + "/src/Controller.cpp")
        _create_file(FILE_CONTENT_CONTROLLER_ACTION_H, args.project_dir + "/include/Controller.h")

    logger.info('A WRENCH-based skeleton project using the %s API has been created in directory %s' % (
        args.api, args.project_dir))

if __name__ == '__main__':
    main()
